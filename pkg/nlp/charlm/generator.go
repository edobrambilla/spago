// Copyright 2020 spaGO Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package charlm

import (
	mat "github.com/nlpodyssey/spago/pkg/mat32"
	"github.com/nlpodyssey/spago/pkg/ml/ag"
	"github.com/nlpodyssey/spago/pkg/ml/nn"
	"github.com/nlpodyssey/spago/pkg/utils"
	"strings"
)

// Generator is a character-level language model text generator.
type Generator struct {
	GeneratorConfig
	model *Model
}

// GeneratorConfig provides configuration settings for a Character-level Language Model Generator.
type GeneratorConfig struct {
	MaxCharacters int
	StopAtEOS     bool
	Temperature   mat.Float
}

// NewGenerator returns a new Generator.
func NewGenerator(model *Model, config GeneratorConfig) *Generator {
	return &Generator{
		GeneratorConfig: config,
		model:           model,
	}
}

// GenerateText returns a new sequences of text generated by the learned language model, and its log probability.
// The output text has a maximum length defined in the generator configuration.
// The text is incrementally constructed character by character, using all previously sampled characters as input
// to predict the next one.
func (m *Generator) GenerateText(prefix string) (text string, logProb mat.Float) {
	if prefix == "" {
		prefix = m.model.SequenceSeparator
	}
	g := ag.NewGraph()
	proc := nn.Reify(nn.Context{Graph: g, Mode: nn.Inference}, m.model).(*Model)
	characters := make([]string, 0)
	next, prob := m.generateNext(proc, utils.SplitByRune(prefix)...)
	characters = append(characters, next)
	logProb += prob
	for i := len(prefix); i < m.MaxCharacters; i++ {
		lastChar := characters[len(characters)-1]
		if m.StopAtEOS && lastChar == m.model.SequenceSeparator {
			break
		}
		next, prob := m.generateNext(proc, lastChar)
		characters = append(characters, next)
		logProb += prob
	}
	text = prefix + strings.Join(characters, "")
	logProb /= mat.Float(len(characters))
	return
}

func (m *Generator) generateNext(proc *Model, xs ...string) (next string, prob mat.Float) {
	lastIndex := len(xs) - 1
	prediction := proc.Forward(xs).([]ag.Node)[lastIndex].Value().Data() // keep the last prediction only
	index := sample(prediction, m.Temperature)
	next = m.model.Vocabulary.MustTerm(index)
	prob = prediction[index]
	return
}
